<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Chan-sccp-users] Chan-sccp-users Digest, Vol 32, Issue 2
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/chan-sccp-users/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:chan-sccp-users%40lists.berlios.de?Subject=Re%3A%20%5BChan-sccp-users%5D%20Chan-sccp-users%20Digest%2C%20Vol%2032%2C%20Issue%202&In-Reply-To=%3C00A24AA921915B4D99E90311BC1632F00D4499%40exchange2k3.five-fifteen.local%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000487.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Chan-sccp-users] Chan-sccp-users Digest, Vol 32, Issue 2</H1>
    <B>Juan A. Quintana</B> 
    <A HREF="mailto:chan-sccp-users%40lists.berlios.de?Subject=Re%3A%20%5BChan-sccp-users%5D%20Chan-sccp-users%20Digest%2C%20Vol%2032%2C%20Issue%202&In-Reply-To=%3C00A24AA921915B4D99E90311BC1632F00D4499%40exchange2k3.five-fifteen.local%3E"
       TITLE="[Chan-sccp-users] Chan-sccp-users Digest, Vol 32, Issue 2">jquintana at simplifieditsolutions.com
       </A><BR>
    <I>Wed Nov 25 05:32:10 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000487.html">[Chan-sccp-users] Unable to Make Calls Using SCCP
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#488">[ date ]</a>
              <a href="thread.html#488">[ thread ]</a>
              <a href="subject.html#488">[ subject ]</a>
              <a href="author.html#488">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Thanks for the reply, Peder.

This is the output of my CLI when I make a call:

-------------------------------------------------------------------------------------------------

Asterisk 1.4.22-4 RPM by <A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">vc-rpms at voipconsulting.nl</A>, Copyright (C) 1999 - 2008 Digium, Inc. and others.
Created by Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">markster at digium.com</A>&gt;
Asterisk comes with ABSOLUTELY NO WARRANTY; type 'core show warranty' for details.
This is free software, with components licensed under the GNU General Public
License version 2 and other licenses; you are welcome to redistribute it under
certain conditions. Type 'core show license' for details.
=========================================================================
  == Parsing '/etc/asterisk/asterisk.conf': Found
Connected to Asterisk 1.4.22-4 RPM by <A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">vc-rpms at voipconsulting.nl</A> currently running on trixbox (pid = 22784)
Verbosity was 3 and is now 5
    -- SEP00136090A798: Accessory 'Speaker' is 'OffHook' (0)
    -- SEP00136090A798: Cisco Digit: 00000001 (1) on line 1401
    -- SEP00136090A798: Cisco Digit: 00000001 (1) on line 1401
    -- SEP00136090A798: Cisco Digit: 00000000 (0) on line 1401
    -- SEP00136090A798: Cisco Digit: 00000001 (1) on line 1401
 SCCP: Timeout for callid '11'. Going to dial '1101'
    -- SCCP: Unable to cancel schedule ID 42.
    -- SEP00136090A798: (sccp_pbx_softswitch) New call on line 1401
    -- SEP00136090A798: Accessory 'Speaker' is 'OnHook' (0)
    -- SEP00136090A798: Accessory 'Handset' is 'OffHook' (0)
    -- SEP00136090A798: Accessory 'Handset' is 'OnHook' (0)
    -- SEP00136090A798 is Onhook
    -- SEP00136090A798: Ending call 11 on line 1401
    -- SCCP: Asterisk request to hangup channel SCCP/1401-0000000b
    -- SCCP: Request to schedule delete for channel '11' in 10 seconds
    -- SCCP: Channel '11' freed by schedule.
trixbox*CLI&gt;

-------------------------------------------------------------------------------------------------

This is my extensions.conf:

-------------------------------------------------------------------------------------------------

;--------------------------------------------------------------------------------;
; Do NOT edit this file as it is auto-generated by FreePBX. All modifications to ;
; this file must be done via the web gui. There are alternative files to make    ;
; custom modifications, details at: <A HREF="http://freepbx.org/configuration_files">http://freepbx.org/configuration_files</A>       ;
;--------------------------------------------------------------------------------;
;

; FreePBX
; Copyright (C) 2004 Coalescent Systems Inc (Canada)
; Copyright (C) 2006 Why Pay More 4 Less Pty Ltd (Australia)
; Copyright (C) 2007 Astrogen LLC (USA)
; Released under the GNU GPL Licence version 2.

; dialparties.agi (<A HREF="http://www.sprackett.com/asterisk/">http://www.sprackett.com/asterisk/</A>)
; Asterisk::AGI (<A HREF="http://asterisk.gnuinter.net/">http://asterisk.gnuinter.net/</A>)
; gsm (<A HREF="http://www.ibiblio.org/pub/Linux/utils/compress/!INDEX.short.html">http://www.ibiblio.org/pub/Linux/utils/compress/!INDEX.short.html</A>)
; loligo sounds (<A HREF="http://www.loligo.com/asterisk/sounds/">http://www.loligo.com/asterisk/sounds/</A>)
; mpg123 (<A HREF="http://voip-info.org/wiki-Asterisk+config+musiconhold.conf">http://voip-info.org/wiki-Asterisk+config+musiconhold.conf</A>)

;**************************  -WARNING-  ****************************************
;                                                                              *
; This include file is to be used with extreme caution. In almost all cases    *
; any custom dialplan SHOULD be put in extensions_custom.conf which will       *
; not hurt a FreePBX generated dialplan. In some very rare and custom          *
; situations users may have a need to override what freepbx automatically      *
; generates. If so anything in this file will do that.  If you come up with a  *
; situation where you need to modify the existing dialplan or macro, please    *
; put it here and also notify the FreePBX development team so they can take it *
; into account in the future.                                                  *
;                                                                              *
#include extensions_override_freepbx.conf
;                                                                              *
;**************************  -WARNING-  ****************************************

; include extension contexts generated from AMP
#include extensions_additional.conf

; Customizations to this dialplan should be made in extensions_custom.conf
; See extensions_custom.conf.sample for an example.
; If you need to use [macro-dialout-trunk-predial-hook], [ext-did-custom], or 
; [from-internal-custom] for example, place these in this file or they will get overwritten.
;
#include extensions_custom.conf

[from-trunk]							; just an alias since VoIP shouldn't be called PSTN
include =&gt; from-pstn

[from-pstn]
include =&gt; from-pstn-custom                     ; create this context in extensions_custom.conf to include customizations
include =&gt; ext-did
include =&gt; ext-did-post-custom
include =&gt; from-did-direct		; MODIFICATOIN (PL) for findmefollow if enabled, should be bofore ext-local
include =&gt; ext-did-catchall		; THIS MUST COME AFTER ext-did
exten =&gt; fax,1,Goto(ext-fax,in_fax,1)

; MODIFICATION (PL) 
;
; Required to assure that direct dids go to personal ring group before local extension.
; This could be auto-generated however I it is prefered to be put here and hard coded
; so that it can be modified if ext-local should take precedence in certain situations.
; will have to decide what to do later.
;
[from-did-direct]
include =&gt; ext-findmefollow
include =&gt; ext-local



; ############################################################################
; Macros [macro]
; ############################################################################

; Rings one or more extensions.  Handles things like call forwarding and DND
; We don't call dial directly for anything internal anymore.
; ARGS: $TIMER, $OPTIONS, $EXT1, $EXT2, $EXT3, ...
; Use a Macro call such as the following: 
;  Macro(dial,$DIAL_TIMER,$DIAL_OPTIONS,$EXT1,$EXT2,$EXT3,...)
[macro-dial]
exten =&gt; s,1,GotoIf($[&quot;${MOHCLASS}&quot; = &quot;&quot;]?dial)
exten =&gt; s,n,SetMusicOnHold(${MOHCLASS})
exten =&gt; s,n(dial),AGI(dialparties.agi)
exten =&gt; s,n,NoOp(Returned from dialparties with no extensions to call and DIALSTATUS: ${DIALSTATUS})

exten =&gt; s,n+2(normdial),Dial(${ds})                               ; dialparties will set the priority to 10 if $ds is not null
exten =&gt; s,n,Set(DIALSTATUS=${IF($[&quot;${DIALSTATUS_CW}&quot;!=&quot;&quot; ]?${DIALSTATUS_CW}:${DIALSTATUS})})
exten =&gt; s,n,GosubIf($[&quot;${SCREEN}&quot; != &quot;&quot;]?${DIALSTATUS},1)

exten =&gt; s,20(huntdial),NoOp(Returned from dialparties with hunt groups to dial )
exten =&gt; s,n,Set(HuntLoop=0)
exten =&gt; s,n(a22),GotoIf($[${HuntMembers} &gt;= 1]?a30)  ; if this is from rg-group, don't strip prefix
exten =&gt; s,n,NoOp(Returning there are no members left in the hunt group to ring)

; dialparties.agi has setup the dialstring for each hunt member in a variable labeled HuntMember0, HuntMember1 etc for each iteration
; and The total number in HuntMembers. So for each iteration, we will update the CALLTRACE Data.
;
exten =&gt; s,n+2(a30),Set(HuntMember=HuntMember${HuntLoop})
exten =&gt; s,n,GotoIf($[$[&quot;${CALLTRACE_HUNT}&quot; != &quot;&quot; ] &amp; $[&quot;${RingGroupMethod}&quot; = &quot;hunt&quot; ]]?a32:a35)
exten =&gt; s,n(a32),Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${HuntLoop} + 1])})
exten =&gt; s,n,Set(DB(CALLTRACE/${CT_EXTEN})=${CALLTRACE_HUNT})
exten =&gt; s,n,Goto(s,a42)

;Set Call Trace for each hunt member we are going to call &quot;Memory groups have multiple members to set CALL TRACE For hence the loop
;
exten =&gt; s,n(a35),GotoIf($[$[&quot;${CALLTRACE_HUNT}&quot; != &quot;&quot; ] &amp; $[&quot;${RingGroupMethod}&quot; = &quot;memoryhunt&quot; ]]?a36:a50)  
exten =&gt; s,n(a36),Set(CTLoop=0)
exten =&gt; s,n(a37),GotoIf($[${CTLoop} &gt; ${HuntLoop}]?a42)  ; if this is from rg-group, don't strip prefix
exten =&gt; s,n,Set(CT_EXTEN=${CUT(FILTERED_DIAL,,$[${CTLoop} + 1])})
exten =&gt; s,n,Set(DB(CALLTRACE/${CT_EXTEN})=${CALLTRACE_HUNT})
exten =&gt; s,n,Set(CTLoop=$[1 + ${CTLoop}])
exten =&gt; s,n,Goto(s,a37)
        
exten =&gt; s,n(a42),Dial(${${HuntMember}}${ds})
exten =&gt; s,n,Set(HuntLoop=$[1 + ${HuntLoop}])
exten =&gt; s,n,GotoIf($[$[$[&quot;foo${RingGroupMethod}&quot; != &quot;foofirstavailable&quot;] &amp; $[&quot;foo${RingGroupMethod}&quot; != &quot;foofirstnotonphone&quot;]] | $[&quot;foo${DialStatus}&quot; = &quot;fooBUSY&quot;]]?a46)
exten =&gt; s,n,Set(HuntMembers=0)
exten =&gt; s,n(a46),Set(HuntMembers=$[${HuntMembers} - 1])
exten =&gt; s,n,Goto(s,a22)

exten =&gt; s,n(a50),DBdel(CALLTRACE/${CT_EXTEN})
exten =&gt; s,n,Goto(s,a42)

; For call screening
exten =&gt; NOANSWER,1,Macro(vm,${SCREEN_EXTEN},BUSY,${IVR_RETVM})
exten =&gt; NOANSWER,n,GotoIf($[&quot;${IVR_RETVM}&quot; != &quot;RETURN&quot; | &quot;${IVR_CONTEXT}&quot; = &quot;&quot;]?bye)
exten =&gt; NOANSWER,n,Return
exten =&gt; NOANSWER,n(bye),Macro(hangupcall)
exten =&gt; TORTURE,1,Goto(app-blackhole,musiconhold,1)
exten =&gt; TORTURE,n,Macro(hangupcall)
exten =&gt; DONTCALL,1,Answer
exten =&gt; DONTCALL,n,Wait(1)
exten =&gt; DONTCALL,n,Zapateller()
exten =&gt; DONTCALL,n,Playback(ss-noservice)
exten =&gt; DONTCALL,n,Macro(hangupcall)

; make sure hungup calls go here so that proper cleanup occurs from call confirmed calls and the like
;
exten =&gt; h,1,Macro(hangupcall)

; Ring an extension, if the extension is busy or there is no answer send it
; to voicemail
; ARGS: $VMBOX, $EXT
[macro-exten-vm]
exten =&gt; s,1,Macro(user-callerid)

exten =&gt; s,n,Set(RingGroupMethod=none)
exten =&gt; s,n,Set(VMBOX=${ARG1})
exten =&gt; s,n,Set(EXTTOCALL=${ARG2})
exten =&gt; s,n,Set(CFUEXT=${DB(CFU/${EXTTOCALL})})
exten =&gt; s,n,Set(CFBEXT=${DB(CFB/${EXTTOCALL})})
exten =&gt; s,n,Set(RT=${IF($[$[&quot;${VMBOX}&quot;!=&quot;novm&quot;] | $[&quot;foo${CFUEXT}&quot;!=&quot;foo&quot;]]?${RINGTIMER}:&quot;&quot;)})
exten =&gt; s,n,Macro(record-enable,${EXTTOCALL},IN)
exten =&gt; s,n,Macro(dial,${RT},${DIAL_OPTIONS},${EXTTOCALL})
exten =&gt; s,n,GotoIf($[ $[&quot;${VMBOX}&quot; != &quot;novm&quot;] &amp; $[&quot;${SCREEN}&quot; != &quot;&quot;] &amp; $[&quot;${DIALSTATUS}&quot; = &quot;NOANSWER&quot;] ]?exit,return)
exten =&gt; s,n,Set(SV_DIALSTATUS=${DIALSTATUS})
exten =&gt; s,n,GosubIf($[$[&quot;${SV_DIALSTATUS}&quot;=&quot;NOANSWER&quot;] &amp; $[&quot;${CFUEXT}&quot;!=&quot;&quot;] &amp; $[&quot;${SCREEN}&quot; = &quot;&quot;]]?docfu,1) ; check for CFU in use on no answer
exten =&gt; s,n,GosubIf($[$[&quot;${SV_DIALSTATUS}&quot;=&quot;BUSY&quot;] &amp; $[&quot;${CFBEXT}&quot;!=&quot;&quot;]]?docfb,1) ; check for CFB in use on busy
exten =&gt; s,n,Set(DIALSTATUS=${SV_DIALSTATUS})
exten =&gt; s,n,NoOp(Voicemail is '${VMBOX}')
exten =&gt; s,n,GotoIf($[&quot;${VMBOX}&quot; = &quot;novm&quot;]?s-${DIALSTATUS},1) ; no voicemail in use for this extension
exten =&gt; s,n,NoOp(Sending to Voicemail box ${EXTTOCALL})
exten =&gt; s,n,Macro(vm,${VMBOX},${DIALSTATUS},${IVR_RETVM})

; Try the Call Forward on No Answer / Unavailable number
exten =&gt; docfu,1,Set(RTCFU=${IF($[&quot;${VMBOX}&quot;!=&quot;novm&quot;]?${RINGTIMER}:&quot;&quot;)})
exten =&gt; docfu,n,Dial(Local/${CFUEXT}@from-internal/n,${RTCFU},${DIAL_OPTIONS})
exten =&gt; docfu,n,Return

; Try the Call Forward on Busy number
exten =&gt; docfb,1,Set(RTCFB=${IF($[&quot;${VMBOX}&quot;!=&quot;novm&quot;]?${RINGTIMER}:&quot;&quot;)})
exten =&gt; docfb,n,Dial(Local/${CFBEXT}@from-internal/n,${RTCFB},${DIAL_OPTIONS})
exten =&gt; docfb,n,Return

; Extensions with no Voicemail box reporting BUSY come here
exten =&gt; s-BUSY,1,NoOp(Extension is reporting BUSY and not passing to Voicemail)
exten =&gt; s-BUSY,n,GotoIf($[&quot;${IVR_RETVM}&quot; = &quot;RETURN&quot; &amp; &quot;${IVR_CONTEXT}&quot; != &quot;&quot;]?exit,1)
exten =&gt; s-BUSY,n,Playtones(busy)
exten =&gt; s-BUSY,n,Busy(20)

; Anything but BUSY comes here
exten =&gt; _s-.,1,Noop(IVR_RETVM: ${IVR_RETVM} IVR_CONTEXT: ${IVR_CONTEXT})
exten =&gt; _s-.,n,GotoIf($[&quot;${IVR_RETVM}&quot; = &quot;RETURN&quot; &amp; &quot;${IVR_CONTEXT}&quot; != &quot;&quot;]?exit,1)
exten =&gt; _s-.,n,Playtones(congestion)
exten =&gt; _s-.,n,Congestion(10)

; Short burst of tones then return
exten =&gt; exit,1,Playback(beep&amp;line-busy-transfer-menu&amp;silence/1)
exten =&gt; exit,n(return),MacroExit()

;------------------------------------------------------------------------
; [macro-vm]
;------------------------------------------------------------------------
; CONTEXT:      macro-vm
; PURPOSE:      call voicemail system and extend with personal ivr
;
; Under normal use, this macro will call the voicemail system with the extension and
; desired greeting mode of busy, unavailable or as specified with direct voicemail
; calls (usually unavailable) when entered from destinations.
;
; The voicemail system's two greetings have been 'hijacked' as follows to extend the
; system by giving the option of a private 'ivr' for each voicemail user. The following
; applies to both the busy and unavailable modes of voicemail and can be applied to one
; or both, and differently.
;
; Global Defaults:
;
; The following are default values, used in both busy and unavail modes if no specific
; values are specified.
;
; VMX_REPEAT
;					The number of times to repeat the users message if no option is pressed.
; VMX_TIMEOUT
;					The timeout to wait after playing message before repeating or giving up.
; VMX_LOOPS
;					The number of times it should replay the message and check for an option when
;					an invalid option is pressed.
;
; VMX_OPTS_DOVM
;					Default voicemail option to use if vm is chosen as an option. No options will
;					cause Allison's generic message, 's' will go straight to beep.
; VMX_OPTS_TIMEOUT
;					Default voicemail option to use if it times out with no options. No options will
;					cause Allison's generic message, 's' will go straight to beep.
;					IF THE USER PRESSES # - it will look like a timeout as well since no option will
;					be presented. If the user wishes to enable a mode where a caller can press #
;					during their message and it goes straight to voicemail with only a 'beep' then
;					this should be set to 's'.
; VMX_OPTS_LOOPS
;					Default voicemail option to use if to many wrong options occur. No options will
;					cause Allison's generic message, 's' will go straight to beep.
;
; VMX_CONTEXT
;					Default context for user destinations if not supplied in the user's settings
; VMX_PRI
;					Default priority for user destinations if not supplied in the user's settings
;
; VMX_TIMEDEST_CONTEXT
;					Default context for timeout destination if not supplied in the user's settings
; VMX_TIMEDEST_EXT
;					Default extension for timeout destination if not supplied in the user's settings
; VMX_TIMEDEST_PRI
;					Default priority for timeout destination if not supplied in the user's settings
;
; VMX_LOOPDEST_CONTEXT
;					Default context for loops  destination if not supplied in the user's settings
; VMX_LOOPDEST_EXT
;					Default extension for loops  destination if not supplied in the user's settings
; VMX_LOOPDEST_PRI
;					Default priority for loops  destination if not supplied in the user's settings
;
;
; The AMPUSER database variable has been extended with a 'vmx' tree (vm-extension). A
; duplicate set is included for both unavail and busy. You could choose for to have an
; ivr when unavail is taken, but not with busy - or a different once with busy.
; The full list is below, each specific entry is futher described:
;
; state:		Whether teh current mode is enabled or disabled. Anything but 'enabled' is
;						treated as disabled.
; repeat:		This is the number of times that the users message should be played after the
;						timeout if the user has not entered anything. It is just a variable to the
;						Read() function which will do the repeating.
; timeout:	This is how long to wait after the message has been read for a response from
;						the user. A caller can enter a digit any time during the playback.
; loops:		This is the number of loops that the system will allow a caller to retry if
;						they enter a bad menu choice, before going to the loop failover destination
; vmxopts:	This is the vm options to send to the voicemail command used when a specific
;						voicemail destination is chosen (inidcated by 'dovm' in the ext field). This is
;						typically either set to 's' or left blank. When set to 's' there will be no
;						message played when entering the voicemail, just a beep. When blank, you will
;						have Allison's generic message played. It is not typical to play the greetings
;						since they have been 'hijacked' for these IVR's and from a caller's perspecitive
;						this system appears interconnected with the voicemail so instructions can be
;						left there.
; timedest: The three variables: ext, context and pri are the goto destination if the caller
;						enters no options and it timesout. None have to be set and a system default
;						will be used. If just ext is set, then defaults will be used for context and
;						pri, etc.
; loopdest:	This is identical to timedest but used if the caller exceeds the maximum invalid
;						menu choices.
; [0-9*]:		The user can specify up to 11 ivr options, all as single digits from 0-9 or *. The
;						# key can not be used since it is used as a terminator key for the Read command
;						and will never be returned. A minimum of the ext must be specified for each valid
;						option and as above, the context and priority can also be specified if the default
;						is not to be used.
;						Option '0' takes on a special meaning. Since a user is able to break out of the
;						voicemail command once entering it with a 0, if specified, the 0 destination will
;						be used.
;						Option '*' can also be used to breakout. It is undecided at this point whether
;						providing that option will be used as well. (probably should).
;
;
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/state:								enabled|disabled
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/repeat:								n (times to repeat message)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/timeout:							n (timeout to wait for digit)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/loops:								n (loop returies for invalid entries)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/vmxopts/dovm:					vmoptions (if ext is dovm)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/vmxopts/timeout:			vmoptions (if timeout)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/vmxopts/loops:				vmoptions (if loops)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/timedest/ext:					extension (if timeout)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/timedest/context:			context (if timeout)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/timedest/pri:					priority (if timeout)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/loopdest/ext:					extension (if too many failures)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/loopdest/context:			context (if too many failures)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/loopdest/pri:					priority (if too many failures)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/[0-9*]/ext:						extension (dovm for vm access)
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/[0-9*]/context:				context 
; /AMPUSER/&lt;ext&gt;/vmx/[busy|unavail]/[0-9*]/pri:						priority 
;------------------------------------------------------------------------
[macro-vm]
; ARG1 - extension
; ARG2 - DIRECTDIAL/BUSY
; ARG3 - RETURN makes macro return, otherwise hangup
exten =&gt; s,1,Macro(user-callerid,SKIPTTL)
exten =&gt; s,n,Set(VMGAIN=${IF($[&quot;foo${VM_GAIN}&quot;!=&quot;foo&quot;]?&quot;g(${VM_GAIN})&quot;:&quot;&quot;)})
;
; If BLKVM_OVERRIDE is set, then someone told us to block calls from going to
; voicemail. This variable is reset by the answering channel so subsequent
; transfers will properly function.
;
exten =&gt; s,n,GotoIf($[&quot;foo${DB(${BLKVM_OVERRIDE})}&quot; != &quot;fooTRUE&quot;]?vmx,1)
;
; we didn't branch so block this from voicemail
;
exten =&gt; s,n,Noop(CAME FROM: ${NODEST} - Blocking VM cause of key: ${DB(BLKVM_OVERRIDE)})
exten =&gt; s,n,Hangup


; If vmx not enabled for the current mode,then jump to normal voicemail behavior
; also - if not message (no-msg) is requested, straight to voicemail
;
exten =&gt; vmx,1,GotoIf($[&quot;${ARG2}&quot;=&quot;NOMESSAGE&quot;]?s-${ARG2},1)
exten =&gt; vmx,n,Set(MODE=${IF($[&quot;${ARG2}&quot;=&quot;BUSY&quot;]?busy:unavail)})
exten =&gt; vmx,n,GotoIf($[&quot;${ARG2}&quot; != &quot;DIRECTDIAL&quot;]?notdirect)
exten =&gt; vmx,n,Set(MODE=${IF($[&quot;${REGEX(&quot;[b]&quot; ${VM_DDTYPE})}&quot; = &quot;1&quot;]?busy:${MODE})})
exten =&gt; vmx,n(notdirect),Noop(Checking if ext ${ARG1} is enabled: ${DB(AMPUSER/${ARG1}/vmx/${MODE}/state)})
exten =&gt; vmx,n,GotoIf($[&quot;${DB(AMPUSER/${ARG1}/vmx/${MODE}/state)}&quot; != &quot;enabled&quot;]?s-${ARG2},1)

; If the required voicemail file does not exist, then abort and go to normal voicemail behavior
;
; TODO: there have been errors using System() with jump to 101 where asterisk works fine at the begining and
;       then starts to jump to 101 even on success. This new mode is being tried with the SYSTEM Status which
;       returns SUCCESS when the command returned succcessfully with a 0 app return code.
;
exten =&gt; vmx,n,Macro(get-vmcontext,${ARG1})
;exten =&gt; vmx,n,TrySystem(/bin/ls ${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${ARG1}/${MODE}.[wW][aA][vV])
exten =&gt; vmx,n,AGI(checksound.agi,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${ARG1}/temp)
exten =&gt; vmx,n,GotoIf($[&quot;${SYSTEMSTATUS}&quot; = &quot;SUCCESS&quot;]?tmpgreet)
exten =&gt; vmx,n,AGI(checksound.agi,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${ARG1}/${MODE})
exten =&gt; vmx,n,GotoIf($[&quot;${SYSTEMSTATUS}&quot; != &quot;SUCCESS&quot;]?nofile)

; Get the repeat, timeout and loop times to use if they are overriden form the global settings
;
exten =&gt; vmx,n,Set(LOOPCOUNT=0)
exten =&gt; vmx,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/repeat)}&quot; = &quot;0&quot;]?vmxtime)
exten =&gt; vmx,n,Set(VMX_REPEAT=${DB_RESULT})
exten =&gt; vmx,n(vmxtime),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/timeout)}&quot; = &quot;0&quot;]?vmxloops)
exten =&gt; vmx,n,Set(VMX_TIMEOUT=${DB_RESULT})
exten =&gt; vmx,n(vmxloops),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/loops)}&quot; = &quot;0&quot;]?vmxanswer)
exten =&gt; vmx,n,Set(VMX_LOOPS=${DB_RESULT})
exten =&gt; vmx,n(vmxanswer),Answer()

; Now play the users voicemail recording as the basis for their ivr, the Read command will repeat as needed and if it timesout
; then we go to the timeout. Otherwise handle invalid options by looping until the limit until a valid option is played.
;
exten =&gt; vmx,n(loopstart),Read(ACTION,${ASTSPOOLDIR}/voicemail/${VMCONTEXT}/${ARG1}/${MODE},1,skip,${VMX_REPEAT},${VMX_TIMEOUT})
exten =&gt; vmx,n,GotoIf($[&quot;${EXISTS(${ACTION})}&quot; = &quot;1&quot;]?checkopt)

; If we are here we timed out, go to the required destination
;
exten =&gt; vmx,n(noopt),Noop(Timeout: going to timeout dest)
exten =&gt; vmx,n,Set(VMX_OPTS=${VMX_OPTS_TIMEOUT})
exten =&gt; vmx,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/vmxopts/timeout)}&quot; = &quot;0&quot;]?chktime)
exten =&gt; vmx,n,Set(VMX_OPTS=${DB_RESULT})
exten =&gt; vmx,n(chktime),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/timedest/ext)}&quot; = &quot;0&quot;]?dotime)
exten =&gt; vmx,n,Set(VMX_TIMEDEST_EXT=${DB_RESULT})
exten =&gt; vmx,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/timedest/context)}&quot; = &quot;0&quot;]?timepri)
exten =&gt; vmx,n,Set(VMX_TIMEDEST_CONTEXT=${DB_RESULT})
exten =&gt; vmx,n(timepri),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/timedest/pri)}&quot; = &quot;0&quot;]?dotime)
exten =&gt; vmx,n,Set(VMX_TIMEDEST_PRI=${DB_RESULT})
exten =&gt; vmx,n(dotime),Goto(${VMX_TIMEDEST_CONTEXT},${VMX_TIMEDEST_EXT},${VMX_TIMEDEST_PRI})

; We got an option, check if the option is defined, or one of the system defaults
;
exten =&gt; vmx,n(checkopt),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/${ACTION}/ext)}&quot; = &quot;1&quot;]?doopt)
exten =&gt; vmx,n,GotoIf($[&quot;${ACTION}&quot; = &quot;0&quot;]?o,1)
exten =&gt; vmx,n,GotoIf($[&quot;${ACTION}&quot; = &quot;*&quot;]?adef,1)

; Got invalid option loop until the max
;
exten =&gt; vmx,n,Set(LOOPCOUNT=$[${LOOPCOUNT} + 1])
exten =&gt; vmx,n,GotoIf($[${LOOPCOUNT} &gt; ${VMX_LOOPS}]?toomany)
exten =&gt; vmx,n,Playback(pm-invalid-option&amp;please-try-again)
exten =&gt; vmx,n,Goto(loopstart)

; tomany: to many invalid options, go to the specified destination
;
exten =&gt; vmx,n(toomany),Noop(Too Many invalid entries, got to invalid dest)
exten =&gt; vmx,n,Set(VMX_OPTS=${VMX_OPTS_LOOPS})
exten =&gt; vmx,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/vmxopts/loops)}&quot; = &quot;0&quot;]?chkloop)
exten =&gt; vmx,n,Set(VMX_OPTS=${DB_RESULT})
exten =&gt; vmx,n(chkloop),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/loopdest/ext)}&quot; = &quot;0&quot;]?doloop)
exten =&gt; vmx,n,Set(VMX_LOOPDEST_EXT=${DB_RESULT})
exten =&gt; vmx,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/loopdest/context)}&quot; = &quot;0&quot;]?looppri)
exten =&gt; vmx,n,Set(VMX_LOOPDEST_CONTEXT=${DB_RESULT}) ;TODO make configurable per above
exten =&gt; vmx,n(looppri),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/loopdest/pri)}&quot; = &quot;0&quot;]?doloop)
exten =&gt; vmx,n,Set(VMX_LOOPDEST_PRI=${DB_RESULT}) ;TODO make configurable per above
exten =&gt; vmx,n(doloop),Goto(${VMX_LOOPDEST_CONTEXT},${VMX_LOOPDEST_EXT},${VMX_LOOPDEST_PRI})

; doopt: execute the valid option that was chosen
;
exten =&gt; vmx,n(doopt),Noop(Got a valid option: ${DB_RESULT})
exten =&gt; vmx,n,Set(VMX_EXT=${DB_RESULT})
;
; Special case, if this option was to go to voicemail, set options and go
;
exten =&gt; vmx,n,GotoIf($[&quot;${VMX_EXT}&quot; != &quot;dovm&quot;]?getdest)
exten =&gt; vmx,n(vmxopts),Set(VMX_OPTS=${VMX_OPTS_DOVM})
exten =&gt; vmx,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/vmxopts/dovm)}&quot; = &quot;0&quot;]?vmxdovm)
exten =&gt; vmx,n(vmxopts),Set(VMX_OPTS=${DB_RESULT})
exten =&gt; vmx,n(vmxdovm),goto(dovm,1)
;
; General case, setup the goto destination and go there (no error checking, its up to the GUI's to assure
; reasonable values
;
exten =&gt; vmx,n(getdest),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/${ACTION}/context)}&quot; = &quot;0&quot;]?vmxpri)
exten =&gt; vmx,n,Set(VMX_CONTEXT=${DB_RESULT})
exten =&gt; vmx,n(vmxpri),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/${ACTION}/pri)}&quot; = &quot;0&quot;]?vmxgoto)
exten =&gt; vmx,n,Set(VMX_PRI=${DB_RESULT})
exten =&gt; vmx,n(vmxgoto),Goto(${VMX_CONTEXT},${VMX_EXT},${VMX_PRI})

; If the required voicemail file is not present, then revert to normal voicemail
; behavior treating as if it was not set
;
exten =&gt; vmx,n(nofile),Noop(File for mode: ${MODE} does not exist, SYSTEMSTATUS: ${SYSTEMSTATUS}, going to normal voicemail)
exten =&gt; vmx,n,Goto(s-${ARG2},1)
exten =&gt; vmx,n(tmpgreet),Noop(Temporary Greeting Detected, going to normal voicemail)
exten =&gt; vmx,n,Goto(s-${ARG2},1)

; Drop into voicemail either as a direct destination (in which case VMX_OPTS might be set to something) or
; if the user timed out or broke out of the loop then VMX_OPTS is always cleared such that an Allison
; message is played and the caller know's what is going on.
;
exten =&gt; dovm,1,Noop(VMX Timeout - go to voicemail)
exten =&gt; dovm,n,Voicemail(${ARG1}@${VMCONTEXT},${VMX_OPTS}${VMGAIN}) ; no flags, so allison plays please leave ...
exten =&gt; dovm,n,Goto(exit-${VMSTATUS},1)

exten =&gt; s-BUSY,1,NoOp(BUSY voicemail)
exten =&gt; s-BUSY,n,Macro(get-vmcontext,${ARG1})
exten =&gt; s-BUSY,n,Voicemail(${ARG1}@${VMCONTEXT},${VM_OPTS}b${VMGAIN})   ; Voicemail Busy message
exten =&gt; s-BUSY,n,Goto(exit-${VMSTATUS},1)

exten =&gt; s-NOMESSAGE,1,NoOp(NOMESSAGE (beeb only) voicemail)
exten =&gt; s-NOMESSAGE,n,Macro(get-vmcontext,${ARG1})
exten =&gt; s-NOMESSAGE,n,Voicemail(${ARG1}@${VMCONTEXT},s${VM_OPTS}${VMGAIN})
exten =&gt; s-NOMESSAGE,n,Goto(exit-${VMSTATUS},1)

exten =&gt; s-DIRECTDIAL,1,NoOp(DIRECTDIAL voicemail)
exten =&gt; s-DIRECTDIAL,n,Macro(get-vmcontext,${ARG1})
exten =&gt; s-DIRECTDIAL,n,Voicemail(${ARG1}@${VMCONTEXT},${VM_OPTS}${VM_DDTYPE}${VMGAIN})
exten =&gt; s-DIRECTDIAL,n,Goto(exit-${VMSTATUS},1)

exten =&gt; _s-.,1,Macro(get-vmcontext,${ARG1})
exten =&gt; _s-.,n,Voicemail(${ARG1}@${VMCONTEXT},${VM_OPTS}u${VMGAIN})     ; Voicemail Unavailable message
exten =&gt; _s-.,n,Goto(exit-${VMSTATUS},1)

; If the user has a 0 option defined, use that for operator zero-out from within voicemail
; as well to keep it consistant with the menu structure
;
exten =&gt; o,1,Background(one-moment-please)      ; 0 during vm message will hangup
exten =&gt; o,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/0/ext)}&quot; = &quot;0&quot;]?doopdef)

exten =&gt; o,n,Set(VMX_OPDEST_EXT=${DB_RESULT})
exten =&gt; o,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/0/context)}&quot; = &quot;1&quot;]?opcontext)
exten =&gt; o,n,Set(DB_RESULT=${VMX_CONTEXT})
exten =&gt; o,n(opcontext),Set(VMX_OPDEST_CONTEXT=${DB_RESULT})
exten =&gt; o,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/0/pri)}&quot; = &quot;1&quot;]?oppri)
exten =&gt; o,n,Set(DB_RESULT=${VMX_PRI})
exten =&gt; o,n(oppri),Set(VMX_OPDEST_PRI=${DB_RESULT})

exten =&gt; o,n,Goto(${VMX_OPDEST_CONTEXT},${VMX_OPDEST_EXT},${VMX_OPDEST_PRI})
exten =&gt; o,n(doopdef),GotoIf($[&quot;x${OPERATOR_XTN}&quot;=&quot;x&quot;]?nooper:from-internal,${OPERATOR_XTN},1)
exten =&gt; o,n(nooper),GotoIf($[&quot;x${FROM_DID}&quot;=&quot;x&quot;]?nodid)
exten =&gt; o,n,Dial(Local/${FROM_DID}@from-pstn)
exten =&gt; o,n,Macro(hangup)
exten =&gt; o,n(nodid),Dial(Local/<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">s at from-pstn</A>)
exten =&gt; o,n,Macro(hangup)

; If the user has a * option defined, use that for the * out from within voicemail
; as well to keep it consistant with the menu structure
;
exten =&gt; a,1,Macro(get-vmcontext,${ARG1})
exten =&gt; a,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/*/ext)}&quot; = &quot;0&quot;]?adef,1)

exten =&gt; a,n,Set(VMX_ADEST_EXT=${DB_RESULT})
exten =&gt; a,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/*/context)}&quot; = &quot;1&quot;]?acontext)
exten =&gt; a,n,Set(DB_RESULT=${VMX_CONTEXT})
exten =&gt; a,n(acontext),Set(VMX_ADEST_CONTEXT=${DB_RESULT})
exten =&gt; a,n,GotoIf($[&quot;${DB_EXISTS(AMPUSER/${ARG1}/vmx/${MODE}/*/pri)}&quot; = &quot;1&quot;]?apri)
exten =&gt; a,n,Set(DB_RESULT=${VMX_PRI})
exten =&gt; a,n(apri),Set(VMX_ADEST_PRI=${DB_RESULT})
exten =&gt; a,n,Goto(${VMX_ADEST_CONTEXT},${VMX_ADEST_EXT},${VMX_ADEST_PRI})

exten =&gt; adef,1,VoiceMailMain(${ARG1}@${VMCONTEXT})
exten =&gt; adef,n,GotoIf($[&quot;${ARG3}&quot; = &quot;RETURN&quot;]?exit-RETURN,1)
exten =&gt; adef,n,Hangup

exten =&gt; exit-FAILED,1,Playback(im-sorry&amp;an-error-has-occured)
exten =&gt; exit-FAILED,n,GotoIf($[&quot;${ARG3}&quot; = &quot;RETURN&quot;]?exit-RETURN,1)
exten =&gt; exit-FAILED,n,Hangup()

exten =&gt; exit-SUCCESS,1,GotoIf($[&quot;${ARG3}&quot; = &quot;RETURN&quot;]?exit-RETURN,1)
exten =&gt; exit-SUCCESS,n,Playback(goodbye)
exten =&gt; exit-SUCCESS,n,Hangup()

exten =&gt; exit-USEREXIT,1,GotoIf($[&quot;${ARG3}&quot; = &quot;RETURN&quot;]?exit-RETURN,1)
exten =&gt; exit-USEREXIT,n,Playback(goodbye)
exten =&gt; exit-USEREXIT,n,Hangup()

exten =&gt; exit-RETURN,1,Noop(Returning From Voicemail because macro)

exten =&gt; t,1,Hangup()
;------------------------------------------------------------------------

;------------------------------------------------------------------------
; [macro-simple-dial]
;------------------------------------------------------------------------
; This macro was derived from macro-exten-vm, which is what is normally used to
; ring an extension. It has been simplified and designed to never go to voicemail
; and always return regardless of the DIALSTATUS for any incomplete call.
;
; It's current primary purpose is to allow findmefollow ring an extension prior
; to trying the follow-me ringgroup that is provided.
;
; Ring an extension, if the extension is busy or there is no answer, return
; ARGS: $EXTENSION, $RINGTIME
;------------------------------------------------------------------------
[macro-simple-dial]
exten =&gt; s,1,Set(EXTTOCALL=${ARG1})
exten =&gt; s,n,Set(RT=${ARG2})
exten =&gt; s,n,Set(CFUEXT=${DB(CFU/${EXTTOCALL})})
exten =&gt; s,n,Set(CFBEXT=${DB(CFB/${EXTTOCALL})})

exten =&gt; s,n,Macro(dial,${RT},${DIAL_OPTIONS},${EXTTOCALL})

exten =&gt; s,n,Set(PR_DIALSTATUS=${DIALSTATUS})

; if we return, thus no answer, and they have a CFU setting, then  we try that next
;
exten =&gt; s,n,GosubIf($[$[&quot;${PR_DIALSTATUS}&quot;=&quot;NOANSWER&quot;] &amp; $[&quot;foo${CFUEXT}&quot;!=&quot;foo&quot;]]?docfu,1) ; check for CFU in use on no answer
exten =&gt; s,n,GosubIf($[$[&quot;${PR_DIALSTATUS}&quot;=&quot;BUSY&quot;] &amp; $[&quot;foo${CFBEXT}&quot;!=&quot;foo&quot;]]?docfb,1) ; check for CFB in use on busy
exten =&gt; s,n,Set(DIALSTATUS=${PR_DIALSTATUS})

; Nothing yet, then go to the end (which will just return, but in case we decide to do something with certain
; return situations, this is left in.
;
exten =&gt; s,n,Goto(s-${DIALSTATUS},1)

; Try the Call Forward on No Answer / Unavailable number.
; We want to try CFU if set, but we want the same ring timer as was set to our call (or do we want the
; system ringtimer? - probably not). Then if no answer there (assuming it doesn't drop into their vm or
; something we return, which will have the net effect of returning to the followme setup.)
;
; want to avoid going to other follow-me settings here. So check if the CFUEXT is a user and if it is
; then direct it straight to ext-local (to avoid getting intercepted by findmefollow) otherwise send it
; to from-internal since it may be an outside line.
;
exten =&gt; docfu,1,GotoIf( $[ &quot;foo${DB(AMPUSER/${CFUEXT}/device)}&quot; = &quot;foo&quot; ]?chlocal)
exten =&gt; docfu,n,Dial(Local/${CFUEXT}@ext-local,${RT},${DIAL_OPTIONS})
exten =&gt; docfu,n,Return
exten =&gt; docfu,n(chlocal),Dial(Local/${CFUEXT}@from-internal/n,${RT},${DIAL_OPTIONS})
exten =&gt; docfu,n,Return

; Try the Call Forward on Busy number
exten =&gt; docfb,1,GotoIf( $[ &quot;foo${DB(AMPUSER/${CFBEXT}/device)}&quot; = &quot;foo&quot; ]?chlocal)
exten =&gt; docfb,n,Dial(Local/${CFBEXT}@ext-local,${RT},${DIAL_OPTIONS})
exten =&gt; docfb,n,Return
exten =&gt; docfb,n(chlocal),Dial(Local/${CFBEXT}@from-internal/n,${RT},${DIAL_OPTIONS})
exten =&gt; docfb,n,Return

; In all cases of no connection, come here and simply return, since the calling dialplan will
; decide what to do next
exten =&gt; _s-.,1,NoOp(Extension is reporting ${EXTEN})
;------------------------------------------------------------------------


; get the voicemail context for the user in ARG1
[macro-get-vmcontext]
exten =&gt; s,1,Set(VMCONTEXT=${DB(AMPUSER/${ARG1}/voicemail)})
exten =&gt; s,2,GotoIf($[&quot;foo${VMCONTEXT}&quot; = &quot;foo&quot;]?200:300)
exten =&gt; s,200,Set(VMCONTEXT=default)
exten =&gt; s,300,NoOp()

; For some reason, if I don't run setCIDname, CALLERID(name) will be blank in my AGI
; ARGS: none
[macro-fixcid]
exten =&gt; s,1,Set(CALLERID(name)=${CALLERID(name)})

; Ring groups of phones
; ARGS: comma separated extension list
; 1 - Ring Group Strategy
; 2 - ringtimer
; 3 - prefix
; 4 - extension list
[macro-rg-group]
exten =&gt; s,1,Macro(user-callerid,SKIPTTL) ; already called from ringgroup
exten =&gt; s,2,GotoIf($[&quot;${CALLERID(name):0:${LEN(${RGPREFIX})}}&quot; != &quot;${RGPREFIX}&quot;]?4:3)  ; check for old prefix
exten =&gt; s,3,Set(CALLERID(name)=${CALLERID(name):${LEN(${RGPREFIX})}}) ; strip off old prefix
exten =&gt; s,4,Set(RGPREFIX=${ARG3})  ; set new prefix
exten =&gt; s,5,Set(CALLERID(name)=${RGPREFIX}${CALLERID(name)})  ; add prefix to callerid name
exten =&gt; s,6,Set(RecordMethod=Group)  ; set new prefix
exten =&gt; s,7,Macro(record-enable,${MACRO_EXTEN},${RecordMethod})
exten =&gt; s,8,Set(RingGroupMethod=${ARG1})     ;
exten =&gt; s,9,Macro(dial,${ARG2},${DIAL_OPTIONS},${ARG4})
exten =&gt; s,10,Set(RingGroupMethod='')     ;


;
; Outgoing channel(s) are busy ... inform the client
; but use noanswer features like ringgroups don't break by being answered
; just to play the message.
;
[macro-outisbusy]
exten =&gt; s,1,Playback(all-circuits-busy-now,noanswer)
exten =&gt; s,n,Playback(pls-try-call-later,noanswer)
exten =&gt; s,n,Macro(hangupcall)

; What to do on hangup.                                         
[macro-hangupcall]
exten =&gt; s,1,ResetCDR(w)
exten =&gt; s,n,NoCDR()
 
; Cleanup any remaining RG flag
;
exten =&gt; s,n,GotoIf($[ &quot;x${USE_CONFIRMATION}&quot; = &quot;x&quot; | &quot;x${RINGGROUP_INDEX}&quot; = &quot;x&quot; | &quot;${CHANNEL}&quot; != &quot;${UNIQCHAN}&quot;]?skiprg)
exten =&gt; s,n,Noop(Cleaning Up Confirmation Flag: RG/${RINGGROUP_INDEX}/${CHANNEL})
exten =&gt; s,n,DBDel(RG/${RINGGROUP_INDEX}/${CHANNEL})

; Cleanup any remaining BLKVM flag
;
exten =&gt; s,n(skiprg),GotoIf($[ &quot;x${BLKVM_BASE}&quot; = &quot;x&quot; | &quot;BLKVM/${BLKVM_BASE}/${CHANNEL}&quot; != &quot;${BLKVM_OVERRIDE}&quot; ]?skipblkvm)
exten =&gt; s,n,Noop(Cleaning Up Block VM Flag: ${BLKVM_OVERRIDE})
exten =&gt; s,n,DBDel(${BLKVM_OVERRIDE})

; Cleanup any remaining FollowMe DND flags
;
exten =&gt; s,n(skipblkvm),GotoIf($[ &quot;x${FMGRP}&quot; = &quot;x&quot; | &quot;x${FMUNIQUE}&quot; = &quot;x&quot; | &quot;${CHANNEL}&quot; != &quot;${FMUNIQUE}&quot; ]?theend)
exten =&gt; s,n,DBDel(FM/DND/${FMGRP}/${CHANNEL})

exten =&gt; s,n(theend),Hangup

[macro-faxreceive]
exten =&gt; s,1,Set(FAXFILE=${ASTSPOOLDIR}/fax/${UNIQUEID}.tif)
exten =&gt; s,2,Set(EMAILADDR=${FAX_RX_EMAIL})
exten =&gt; s,3,rxfax(${FAXFILE})
exten =&gt; s,103,Set(EMAILADDR=${FAX_RX_EMAIL})
exten =&gt; s,104,Goto(3)

; dialout and strip the prefix
[macro-dialout]
exten =&gt; s,1,Macro(user-callerid,SKIPTTL)
exten =&gt; s,2,GotoIf($[&quot;${ECID${CALLERID(number)}}&quot; = &quot;&quot;]?5) 	;check for CID override for exten
exten =&gt; s,3,Set(CALLERID(all)=${ECID${CALLERID(number)}})
exten =&gt; s,4,Goto(7)
exten =&gt; s,5,GotoIf($[&quot;${OUTCID_${ARG1}}&quot; = &quot;&quot;]?7) 		;check for CID override for trunk
exten =&gt; s,6,Set(CALLERID(all)=${OUTCID_${ARG1}})
exten =&gt; s,7,Set(length=${LEN(${DIAL_OUT_${ARG1}})})
exten =&gt; s,8,Dial(${OUT_${ARG1}}/${ARG2:${length}})
exten =&gt; s,9,Playtones(congestion)
exten =&gt; s,10,Congestion(5)
exten =&gt; s,109,Macro(outisbusy)


; dialout using default OUT trunk - no prefix
[macro-dialout-default]
exten =&gt; s,1,Macro(user-callerid,SKIPTTL)
exten =&gt; s,2,Macro(record-enable,${CALLERID(number)},OUT)
exten =&gt; s,3,Macro(outbound-callerid,${ARG1})
exten =&gt; s,4,Dial(${OUT}/${ARG1})
exten =&gt; s,5,Playtones(congestion)
exten =&gt; s,6,Congestion(5)
exten =&gt; s,105,Macro(outisbusy)

[macro-dialout-trunk-predial-hook]
; this macro intentially left blank so it may be safely overwritten for any custom
; requirements that an installation may have.
;
; MACRO RETURN CODE: ${PREDIAL_HOOK_RET}
;                    if set to &quot;BYPASS&quot; then this trunk will be skipped
;
exten =&gt; s,1,MacroExit()

; This macro is for dev purposes and just dumps channel/app variables.  Useful when designing new contexts. 
[macro-dumpvars]
exten =&gt; s,1,Noop(ACCOUNTCODE=${ACCOUNTCODE})
exten =&gt; s,2,Noop(ANSWEREDTIME=${ANSWEREDTIME})
exten =&gt; s,3,Noop(BLINDTRANSFER=${BLINDTRANSFER})
exten =&gt; s,4,Noop(CALLERID=${CALLERID(all)})
exten =&gt; s,5,Noop(CALLERID(name)=${CALLERID(name)})
exten =&gt; s,6,Noop(CALLERID(number)=${CALLERID(number)})
exten =&gt; s,7,Noop(CALLINGPRES=${CALLINGPRES})
exten =&gt; s,8,Noop(CHANNEL=${CHANNEL})
exten =&gt; s,9,Noop(CONTEXT=${CONTEXT})
exten =&gt; s,10,Noop(DATETIME=${DATETIME})
exten =&gt; s,11,Noop(DIALEDPEERNAME=${DIALEDPEERNAME})
exten =&gt; s,12,Noop(DIALEDPEERNUMBER=${DIALEDPEERNUMBER})
exten =&gt; s,13,Noop(DIALEDTIME=${DIALEDTIME})
exten =&gt; s,14,Noop(DIALSTATUS=${DIALSTATUS})
exten =&gt; s,15,Noop(DNID=${DNID})
exten =&gt; s,16,Noop(EPOCH=${EPOCH})
exten =&gt; s,17,Noop(EXTEN=${EXTEN})
exten =&gt; s,18,Noop(HANGUPCAUSE=${HANGUPCAUSE})
exten =&gt; s,19,Noop(INVALID_EXTEN=${INVALID_EXTEN})
exten =&gt; s,20,Noop(LANGUAGE=${LANGUAGE})
exten =&gt; s,21,Noop(MEETMESECS=${MEETMESECS})
exten =&gt; s,22,Noop(PRIORITY=${PRIORITY})
exten =&gt; s,23,Noop(RDNIS=${RDNIS})
exten =&gt; s,24,Noop(SIPDOMAIN=${SIPDOMAIN})
exten =&gt; s,25,Noop(SIP_CODEC=${SIP_CODEC})
exten =&gt; s,26,Noop(SIPCALLID=${SIPCALLID})
exten =&gt; s,27,Noop(SIPUSERAGENT=${SIPUSERAGENT})
exten =&gt; s,29,Noop(TXTCIDNAME=${TXTCIDNAME})
exten =&gt; s,30,Noop(UNIQUEID=${UNIQUEID})
exten =&gt; s,31,Noop(TOUCH_MONITOR=${TOUCH_MONITOR})
exten =&gt; s,32,Noop(MACRO_CONTEXT=${MACRO_CONTEXT})
exten =&gt; s,33,Noop(MACRO_EXTEN=${MACRO_EXTEN})
exten =&gt; s,34,Noop(MACRO_PRIORITY=${MACRO_PRIORITY})

[macro-user-logon]
; check device type
;
exten =&gt; s,1,Set(DEVICETYPE=${DB(DEVICE/${CALLERID(number)}/type)})
exten =&gt; s,n,Answer()
exten =&gt; s,n,Wait(1)
exten =&gt; s,n,GotoIf($[&quot;${DEVICETYPE}&quot; = &quot;fixed&quot;]?s-FIXED,1)
; get user's extension
;
exten =&gt; s,n,Set(AMPUSER=${ARG1})
exten =&gt; s,n,GotoIf($[&quot;${AMPUSER}&quot; != &quot;&quot;]?gotpass)
exten =&gt; s,n(playagain),Read(AMPUSER,please-enter-your-extension-then-press-pound,,,4)
; get user's password and authenticate
;
exten =&gt; s,n,GotoIf($[&quot;${AMPUSER}&quot; = &quot;&quot;]?s-MAXATTEMPTS,1)
exten =&gt; s,n(gotpass),GotoIf($[&quot;${DB_EXISTS(AMPUSER/${AMPUSER}/password)}&quot; = &quot;0&quot;]?s-NOUSER,1)
exten =&gt; s,n,Set(AMPUSERPASS=${DB_RESULT})
exten =&gt; s,n,GotoIf($[${LEN(${AMPUSERPASS})} = 0]?s-NOPASSWORD,1)
; do not continue if the user has already logged onto this device
;
exten =&gt; s,n,Set(DEVICEUSER=${DB(DEVICE/${CALLERID(number)}/user)})
exten =&gt; s,n,GotoIf($[&quot;${DEVICEUSER}&quot; = &quot;${AMPUSER}&quot;]?s-ALREADYLOGGEDON,1)
exten =&gt; s,n,Authenticate(${AMPUSERPASS})
exten =&gt; s,n,DeadAGI(user_login_out.agi,login,${CALLERID(number)},${AMPUSER})
exten =&gt; s,n,Playback(vm-goodbye)

exten =&gt; s-FIXED,1,NoOp(Device is FIXED and cannot be logged into)
exten =&gt; s-FIXED,n,Playback(ha/phone)
exten =&gt; s-FIXED,n,SayDigits(${CALLERID(number)})
exten =&gt; s-FIXED,n,Playback(is-curntly-unavail&amp;vm-goodbye)
exten =&gt; s-FIXED,n,Hangup ;TODO should play msg indicated device cannot be logged into 

exten =&gt; s-ALREADYLOGGEDON,1,NoOp(This device has already been logged into by this user)
exten =&gt; s-ALREADYLOGGEDON,n,Playback(vm-goodbye)
exten =&gt; s-ALREADYLOGGEDON,n,Hangup ;TODO should play msg indicated device is already logged into 

exten =&gt; s-NOPASSWORD,1,NoOp(This extension does not exist or no password is set)
exten =&gt; s-NOPASSWORD,n,Playback(pbx-invalid)
exten =&gt; s-NOPASSWORD,n,Goto(s,playagain)

exten =&gt; s-MAXATTEMPTS,1,NoOp(Too many login attempts)
exten =&gt; s-MAXATTEMPTS,n,Playback(vm-goodbye)
exten =&gt; s-MAXATTEMPTS,n,Hangup

exten =&gt; s-NOUSER,1,NoOp(Invalid extension ${AMPUSER} entered)
exten =&gt; s-NOUSER,n,Playback(pbx-invalid)
exten =&gt; s-NOUSER,n,Goto(s,playagain)

[macro-user-logoff]
; check device type
;
exten =&gt; s,1,Set(DEVICETYPE=${DB(DEVICE/${CALLERID(number)}/type)})
exten =&gt; s,n,GotoIf($[&quot;${DEVICETYPE}&quot; = &quot;fixed&quot;]?s-FIXED,1)
exten =&gt; s,n,DeadAGI(user_login_out.agi,logout,${CALLERID(number)})
exten =&gt; s,n(done),Playback(vm-goodbye)

exten =&gt; s-FIXED,1,NoOp(Device is FIXED and cannot be logged out of)
exten =&gt; s-FIXED,n,Playback(an-error-has-occured&amp;vm-goodbye)
exten =&gt; s-FIXED,n,Hangup ;TODO should play msg indicated device cannot be logged into 



; Privacy Manager Macro makes sure that any calls that don't pass the privacy manager are presented
; with congestion since there have been observed cases of the call continuing if not stopped with a 
; congestion, and this provides a slightly more friendly 'sorry' message in case the user is
; legitamately trying to be cooperative. 
;
; Note: the following options are configurable in privacy.conf:
;
;	maxretries = 3 ; default value, number of retries before failing
;	minlength = 10 ; default value, number of digits to be accepted as valid CID
;
[macro-privacy-mgr]
exten =&gt; s,1,Set(KEEPCID=${CALLERID(num)})
exten =&gt; s,n,GotoIf($[&quot;foo${CALLERID(num):0:1}&quot;=&quot;foo+&quot;]?CIDTEST2:CIDTEST1)
exten =&gt; s,n(CIDTEST1),Set(TESTCID=${MATH(1+${CALLERID(num)})})
exten =&gt; s,n,Goto(TESTRESULT)
exten =&gt; s,n(CIDTEST2),Set(TESTCID=${MATH(1+${CALLERID(num):1})})
exten =&gt; s,n(TESTRESULT),GotoIf($[&quot;foo${TESTCID}&quot;=&quot;foo&quot;]?CLEARCID:PRIVMGR)
exten =&gt; s,n(CLEARCID),Set(CALLERID(num)=)
exten =&gt; s,n(PRIVMGR),PrivacyManager()
exten =&gt; s,n,GotoIf($[&quot;${PRIVACYMGRSTATUS}&quot;=&quot;FAILED&quot;]?fail)
exten =&gt; s,n,SetCallerPres(allowed_passed_screen); stop gap until app_privacy.c clears unavailble bit
exten =&gt; s,PRIVMGR+101(fail),Noop(STATUS: ${PRIVACYMGRSTATUS} CID: ${CALLERID(num)} ${CALLERID(name)} CALLPRES: ${CALLLINGPRES})
exten =&gt; s,n,Playback(sorry-youre-having-problems)
exten =&gt; s,n,Playback(goodbye)
exten =&gt; s,n,Playtones(congestion)
exten =&gt; s,n,Congestion(5)



; Text-To-Speech related macros
; These all follow common actions.  First try to playback a file &quot;tts/custom-md5&quot; 
; where &quot;md5&quot; is the md5() of whatever is going to be played. If that doesn't exist,
; try to playback using macro-tts-sayXXXXX (where XXXXX is text/digits/etc, same as
; the macro below). If that macro exits with MACRO_OFFSET=100, then it's done, 
; therwise, fallback to the default asterisk method. 
;
; say text is purely for text-to-speech, there is no fallback
[macro-saytext]
exten =&gt; s,1,Noop(Trying custom SayText playback for &quot;${ARG1}&quot;)
exten =&gt; s,n,Playback(tts/custom-${MD5(${ARG1})})
exten =&gt; s,n,GotoIf($[&quot;${PLAYBACKSTATUS}&quot;=&quot;SUCCESS&quot;]?done)
; call tts-saytext. This should set MACRO_OFFSET=101 if it was successful
exten =&gt; s,n(tts),Macro(tts-saytext,${ARG1},${ARG2},${ARG3})
exten =&gt; s,n,Noop(No text-to-speech handler for SayText, cannot say &quot;${ARG1}&quot;)
exten =&gt; s,n,Goto(done)
exten =&gt; s,tts+101,Noop(tts handled saytext)

; say name is for saying names typically, but fallsback to using SayAlpha
; (saying the word letter-by-letter)
[macro-sayname]
exten =&gt; s,1,Noop(Trying custom SayName playback for &quot;${ARG1}&quot;)
exten =&gt; s,n,Playback(tts/custom-${MD5(${ARG1})})
exten =&gt; s,n,GotoIf($[&quot;${PLAYBACKSTATUS}&quot;=&quot;SUCCESS&quot;]?done)
; call tts-sayalpha. This should set MACRO_OFFSET=101 if it was successful
exten =&gt; s,n(tts),Macro(tts-sayalpha,${ARG1},${ARG2},${ARG3})
exten =&gt; s,n,SayAlpha(${ARG1})
exten =&gt; s,n,Goto(done)
exten =&gt; s,tts+101,Noop(tts handled sayname)

; Say number is for saying numbers (eg &quot;one thousand forty six&quot;) 
[macro-saynumber]
exten =&gt; s,1,Noop(Trying custom SayNumber playback for &quot;${ARG1}&quot;)
exten =&gt; s,n,Playback(tts/custom-${MD5(${ARG1})})
exten =&gt; s,n,GotoIf($[&quot;${PLAYBACKSTATUS}&quot;=&quot;SUCCESS&quot;]?done)
; call tts-saynumber. This should set MACRO_OFFSET=101 if it was successful
exten =&gt; s,n(tts),Macro(tts-saynumber,${ARG1},${ARG2},${ARG3})
exten =&gt; s,n,SayNumber(${ARG1})
exten =&gt; s,n,Goto(done)
exten =&gt; s,tts+101,Noop(tts handled saynumber)

; Say digits is for saying digits one-by-one (eg, &quot;one zero four six&quot;)
[macro-saydigits]
exten =&gt; s,1,Noop(Trying custom SayDigits playback for &quot;${ARG1}&quot;)
exten =&gt; s,n,Playback(tts/custom-${MD5(${ARG1})})
exten =&gt; s,n,GotoIf($[&quot;${PLAYBACKSTATUS}&quot;=&quot;SUCCESS&quot;]?done)
; call tts-saydigits. This should set MACRO_OFFSET=101 if it was successful
exten =&gt; s,n(tts),Macro(tts-saydigits,${ARG1},${ARG2},${ARG3})
exten =&gt; s,n,SayDigits(${ARG1})
exten =&gt; s,n,Goto(done)


;
; ############################################################################
; Inbound Contexts [from]
; ############################################################################

[from-sip-external]
;give external sip users congestion and hangup
; Yes. This is _really_ meant to be _. - I know asterisk whinges about it, but 
; I do know what I'm doing. This is correct.
exten =&gt; _.,1,NoOp(Received incoming SIP connection from unknown peer to ${EXTEN})
exten =&gt; _.,n,Set(DID=${IF($[&quot;${EXTEN:1:2}&quot;=&quot;&quot;]?s:${EXTEN})})
exten =&gt; _.,n,Goto(s,1)
exten =&gt; s,1,GotoIf($[&quot;${ALLOW_SIP_ANON}&quot;=&quot;yes&quot;]?from-trunk,${DID},1)
exten =&gt; s,n,Set(TIMEOUT(absolute)=15)
exten =&gt; s,n,Answer
exten =&gt; s,n,Wait(2)
exten =&gt; s,n,Playback(ss-noservice)
exten =&gt; s,n,Playtones(congestion)
exten =&gt; s,n,Congestion(5)
exten =&gt; h,1,NoOp(Hangup)
exten =&gt; i,1,NoOp(Invalid)
exten =&gt; t,1,NoOp(Timeout)

[from-internal-xfer]
; applications are now mostly all found in from-internal-additional in _custom.conf
include =&gt; parkedcalls
include =&gt; from-internal-custom
;allow phones to dial other extensions
include =&gt; ext-fax
;allow phones to access generated contexts
;
; MODIFIED (PL)
;
; Currently the include for findmefollow is being auto-generated before ext-local which is the desired behavior.
; However, I haven't been able to do anything that I know of to force this. We need to determine if it should
; be hardcoded into here to make sure it doesn't change with some configuration. For now I will leave it out
; until we can discuss this.
;
include =&gt; ext-local-confirm
include =&gt; findmefollow-ringallv2
include =&gt; from-internal-additional
; This causes grief with '#' transfers, commenting out for the moment.
; include =&gt; bad-number
exten =&gt; s,1,Macro(hangupcall)
exten =&gt; h,1,Macro(hangupcall)

[from-internal]
include =&gt; from-internal-xfer
include =&gt; bad-number

;------------------------------------------------------------------------
; [macro-setmusic]
;------------------------------------------------------------------------
; CONTEXT:      macro-setmusic
; PURPOSE:      to turn off moh on routes where it is not desired
;
;------------------------------------------------------------------------
[macro-setmusic]
exten =&gt; s,1,NoOp(Setting Outbound Route MoH To: ${ARG1})
exten =&gt; s,2,SetMusicOnHold(${ARG1})
;------------------------------------------------------------------------

; ##########################################
; ## Ring Groups with Confirmation macros ##
; ##########################################
; Used by followme and ringgroups

;------------------------------------------------------------------------
; [macro-dial-confirm]
;------------------------------------------------------------------------
; This has now been incorporated into dialparties. It still only works with ringall
; and ringall-prim strategies. Have not investigated why it doesn't work with
; hunt and memory hunt.
;
;------------------------------------------------------------------------
[macro-dial-confirm]
; This was written to make it easy to use macro-dial-confirm instead of macro-dial in generated dialplans.
; This takes the same paramaters, with an additional paramater of the ring group Number
; ARG1 is the timeout
; ARG2 is the DIAL_OPTIONS
; ARG3 is a list of xtns to call - 203-222-240-123123123#-211
; ARG4 is the ring group number

; This sets a unique value to indicate that the channel is ringing. This is used for warning slow
; users that the call has already been picked up.
;
exten =&gt; s,1,Set(DB(RG/${ARG4}/${CHANNEL})=RINGING)

; We need to keep that channel variable, because it'll change when we do this dial, so set it to
; fallthrough to every sibling.
;
exten =&gt; s,n,Set(__UNIQCHAN=${CHANNEL})

; The calling ringgroup should have set RingGroupMethod appropriately. We need to set two
; additional parameters:
;
; USE_CONFIRMATION, RINGGROUP_INDEX
;
; Thse are passed to inform dialparties to place external calls through the [grps] context
;
exten =&gt; s,n,Set(USE_CONFIRMATION=TRUE)
exten =&gt; s,n,Set(RINGGROUP_INDEX=${ARG4})
exten =&gt; s,n,Set(ARG4=) ; otherwise it gets passed to dialparties.agi which processes it (prob bug) 

exten =&gt; s,n,Macro(dial,${ARG1},${ARG2},${ARG3})

; delete the variable, if we are here, we are done trying to dial and it may have been left around
;
exten =&gt; s,n,DBDel(RG/${RINGGROUP_INDEX}/${CHANNEL})
exten =&gt; s,n,Set(USE_CONFIRMATION=)
exten =&gt; s,n,Set(RINGGROUP_INDEX=)
;------------------------------------------------------------------------


;------------------------------------------------------------------------
; [ext-local-confirm]
;------------------------------------------------------------------------
; If call confirm is being used in a ringgroup, then calls that do not require confirmation are sent
; to this extension instead of straight to the device.
;
; The sole purpose of sending them here is to make sure we run Macro(auto-confirm) if this
; extension answers the line. This takes care of clearing the database key that is used to inform
; other potential late comers that the extension has been answered by someone else.
;
; ALERT_INFO is deprecated in Asterisk 1.4 but still used throughout the FreePBX dialplan and
; usually set by dialparties.agi. This allows ineritance. Since no dialparties.agi here, set the
; header if it is set.
;
;------------------------------------------------------------------------
[ext-local-confirm]
exten =&gt; _LC-.,1,Noop(IN ext-local-confirm with - RT: ${RT}, RG_IDX: ${RG_IDX})
exten =&gt; _LC-.,n,GotoIf($[&quot;x${ALERT_INFO}&quot;=&quot;x&quot;]?godial)
exten =&gt; _LC-.,n,SIPAddHeader(Alert-Info: ${ALERT_INFO})
exten =&gt; _LC-.,n(godial),dial(${DB(DEVICE/${EXTEN:3}/dial)},${RT},M(auto-confirm^${RG_IDX})${DIAL_OPTIONS})

;------------------------------------------------------------------------
; [findmefollow-ringallv2]
;------------------------------------------------------------------------
; This context, to be included in from-internal, implements the PreRing part of findmefollow
; as well as the GroupRing part. It also communicates between the two so that if DND is set
; on the primary extension, and mastermode is enabled, then the other extensions will not ring
;
;------------------------------------------------------------------------
[findmefollow-ringallv2]
exten =&gt; _FMPR-.,1,Noop(In FMPR ${FMGRP} with ${EXTEN:5})
exten =&gt; _FMPR-.,n,Set(RingGroupMethod=)
exten =&gt; _FMPR-.,n,Set(USE_CONFIRMATION=)
exten =&gt; _FMPR-.,n,Set(RINGGROUP_INDEX=)
exten =&gt; _FMPR-.,n,Macro(simple-dial,${EXTEN:5},${FMREALPRERING})
exten =&gt; _FMPR-.,n,GotoIf($[&quot;${DIALSTATUS}&quot; != &quot;BUSY&quot;]?nodnd)
exten =&gt; _FMPR-.,n,Set(DB(FM/DND/${FMGRP}/${FMUNIQUE})=DND)
exten =&gt; _FMPR-.,n(nodnd),Noop(Ending FMPR ${FMGRP} with ${EXTEN:5} and dialstatus ${DIALSTATUS})
exten =&gt; _FMPR-.,n,Hangup()

exten =&gt; _FMGL-.,1,Noop(In FMGL ${FMGRP} with ${EXTEN:5})
exten =&gt; _FMGL-.,n,GotoIf($[&quot;${DB(FM/DND/${FMGRP}/${FMUNIQUE})}&quot; = &quot;DND&quot;]?dodnd)
exten =&gt; _FMGL-.,n,Wait(1)
exten =&gt; _FMGL-.,n,GotoIf($[&quot;${DB(FM/DND/${FMGRP}/${FMUNIQUE})}&quot; = &quot;DND&quot;]?dodnd)
exten =&gt; _FMGL-.,n,Wait(1)
exten =&gt; _FMGL-.,n,GotoIf($[&quot;${DB(FM/DND/${FMGRP}/${FMUNIQUE})}&quot; = &quot;DND&quot;]?dodnd)
exten =&gt; _FMGL-.,n,Wait(${FMPRERING})
exten =&gt; _FMGL-.,n,GotoIf($[&quot;${DB(FM/DND/${FMGRP}/${FMUNIQUE})}&quot; = &quot;DND&quot;]?dodnd)
exten =&gt; _FMGL-.,n,DBDel(FM/DND/${FMGRP}/${FMUNIQUE})
exten =&gt; _FMGL-.,n(dodial),Macro(dial,${FMGRPTIME},${DIAL_OPTIONS},${EXTEN:5})
exten =&gt; _FMGL-.,n,Noop(Ending FMGL ${FMGRP} with ${EXTEN:5} and dialstatus ${DIALSTATUS})
exten =&gt; _FMGL-.,n,Hangup()
exten =&gt; _FMGL-.,n+10(dodnd),DBDel(FM/DND/${FMGRP}/${FMUNIQUE})
exten =&gt; _FMGL-.,n,GotoIf($[&quot;${FMPRIME}&quot; = &quot;FALSE&quot;]?dodial)
exten =&gt; _FMGL-.,n,Noop(Got DND in FMGL ${FMGRP} with ${EXTEN:5} in ${RingGroupMethod} mode, aborting)
exten =&gt; _FMGL-.,n,Hangup()

;------------------------------------------------------------------------
; [block-cf]
;------------------------------------------------------------------------
; This context is set as a target with FORWARD_CONTEXT when Call Forwarding is set to be
; ignored in a ringgoup or other features that may take advantage of this. Server side
; CF is done in dialparties.agi but if a client device forwards a call, it will be caught
; and blocked here.
;------------------------------------------------------------------------
[block-cf]
exten =&gt; _X.,1,Noop(Blocking callforward to ${EXTEN} because CF is blocked)
exten =&gt; _X.,n,Hangup()

;------------------------------------------------------------------------

; ############################################################################
; Extension Contexts [ext]
; ############################################################################

[ext-fax]
exten =&gt; s,1,Answer
exten =&gt; s,2,Goto(in_fax,1)
exten =&gt; in_fax,1,StopPlayTones  
exten =&gt; in_fax,2,GotoIf($[&quot;${FAX_RX}&quot; = &quot;system&quot;]?3:analog_fax,1)
exten =&gt; in_fax,3,Macro(faxreceive)
exten =&gt; in_fax,4,Hangup
exten =&gt; analog_fax,1,GotoIf($[&quot;${FAX_RX}&quot; = &quot;disabled&quot;]?4:2)  ;if fax is disabled, just hang up
exten =&gt; analog_fax,2,Set(DIAL=${DB(DEVICE/${FAX_RX}/dial)});
exten =&gt; analog_fax,3,Dial(${DIAL},20,d)
exten =&gt; analog_fax,4,Hangup
;exten =&gt; out_fax,1,wait(7)
exten =&gt; out_fax,1,txfax(${TXFAX_NAME},caller)
exten =&gt; out_fax,2,Hangup
exten =&gt; h,1,system(/var/lib/asterisk/bin/fax-process.pl --to ${EMAILADDR} --from ${FAX_RX_FROM} --dest &quot;${FROM_DID}&quot; --subject &quot;Fax from ${URIENCODE(${CALLERID(number)})} ${URIENCODE(${CALLERID(name)})}&quot; --attachment fax_${URIENCODE(${CALLERID(number)})}.pdf --type application/pdf --file ${FAXFILE});
exten =&gt; h,2,Hangup()

;this is where parked calls go if they time-out.  Should probably re-ring
[default]
include =&gt; ext-local
exten =&gt; s,1,Playback(vm-goodbye)
exten =&gt; s,2,Macro(hangupcall)

-------------------------------------------------------------------------------------------------

Thanks for the help!!!!


Juan A. Quintana 
www.simplifieditsolutions.com
Simplified IT Solutions
Network Consultant 
8002 Thorncroft Manor Ln
Richmond, TX 77407
&#160;
&#160;
E-mail:
<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">jquintana at simplifieditsolutions.com</A> 

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; Office: 
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 832.798.5989 
We do IT right.



The information contained in this E-mail message is privileged, confidential, and may be protected from disclosure; please be aware that any other use, printing, copying, disclosure or dissemination of this communication may be subject to legal restriction or sanction. If you think that you have received this e-mail message in error, please reply to the sender.

This E-mail message and any attachments hereto have been scanned for viruses and are believed to be free of any virus or other defect that might affect any computer system into which it is received and opened. However, it is the responsibility of the recipient to ensure that it is virus free and no responsibility is accepted by Simplified IT Solutions for any loss or damage arising in any way from its use.



-----Original Message-----
From: <A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users-bounces at lists.berlios.de</A> [mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users-bounces at lists.berlios.de</A>] On Behalf Of <A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users-request at lists.berlios.de</A>
Sent: Tuesday, November 24, 2009 8:22 PM
To: <A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users at lists.berlios.de</A>
Subject: Chan-sccp-users Digest, Vol 32, Issue 2

Send Chan-sccp-users mailing list submissions to
	<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users at lists.berlios.de</A>

To subscribe or unsubscribe via the World Wide Web, visit
	<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">https://lists.berlios.de/mailman/listinfo/chan-sccp-users</A>
or, via email, send a message with subject or body 'help' to
	<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users-request at lists.berlios.de</A>

You can reach the person managing the list at
	<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users-owner at lists.berlios.de</A>

When replying, please edit your Subject line so it is more specific
than &quot;Re: Contents of Chan-sccp-users digest...&quot;


Today's Topics:

   1. Re: Unable to Make Calls Using SCCP (Peder)


----------------------------------------------------------------------

Message: 1
Date: Tue, 24 Nov 2009 20:02:53 -0600
From: &quot;Peder&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">peder at networkoblivion.com</A>&gt;
Subject: Re: [Chan-sccp-users] Unable to Make Calls Using SCCP
To: &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users at lists.berlios.de</A>&gt;
Message-ID: &lt;08d501ca6d73$664d9eb0$32e8dc10$@com&gt;
Content-Type: text/plain; charset=&quot;us-ascii&quot;

Can you post debug of calls and sip.conf and extensions.conf for the
portions relative to the phones.  

 

From: <A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users-bounces at lists.berlios.de</A>
[mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users-bounces at lists.berlios.de</A>] On Behalf Of Juan A.
Quintana
Sent: Tuesday, November 24, 2009 7:36 PM
To: <A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">chan-sccp-users at lists.berlios.de</A>
Subject: [Chan-sccp-users] Unable to Make Calls Using SCCP

 

Hello, all. I have a Cisco 7960G loaded with the SCCP firmware that I am
testing. My problem is that I am able to receive calls but cannot make
calls. If I dial an extension or a 10 digit number I just get a busy tone.

I am able to dial out from my SIP phones without a problem.

I have a couple of ringtones in my tftp folder that are not being downloaded
by the sccp phone,either. Maybe the phone isnt getting the dialplan from the
tftp folder?

Any help is greatly appreciated!

 

 

 


Juan A. Quintana 

 &lt;<A HREF="http://www.simplifieditsolutions.com/">http://www.simplifieditsolutions.com/</A>&gt; www.simplifieditsolutions.com


Simplified IT Solutions
Network Consultant 

8002 Thorncroft Manor Ln
Richmond, TX 77407
 
 


E-mail:
 &lt;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">jquintana at simplifieditsolutions.com</A>&gt;
<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">jquintana at simplifieditsolutions.com</A> 

	                               Office: 

                               832.798.5989 


We do IT right.

 

 &lt;<A HREF="http://www.twitter.com/simplifiedIT">http://www.twitter.com/simplifiedIT</A>&gt; follow-us-on-twitter

 

The information contained in this E-mail message is privileged,
confidential, and may be protected from disclosure; please be aware that any
other use, printing, copying, disclosure or dissemination of this
communication may be subject to legal restriction or sanction. If you think
that you have received this e-mail message in error, please reply to the
sender.

This E-mail message and any attachments hereto have been scanned for viruses
and are believed to be free of any virus or other defect that might affect
any computer system into which it is received and opened. However, it is the
responsibility of the recipient to ensure that it is virus free and no
responsibility is accepted by Simplified IT Solutions for any loss or damage
arising in any way from its use.

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <A HREF="https://lists.berlios.de/pipermail/chan-sccp-users/attachments/20091124/024fdaa0/attachment.html">https://lists.berlios.de/pipermail/chan-sccp-users/attachments/20091124/024fdaa0/attachment.html</A> 
-------------- next part --------------
A non-text attachment was scrubbed...
Name: not available
Type: image/png
Size: 20527 bytes
Desc: not available
Url : <A HREF="https://lists.berlios.de/pipermail/chan-sccp-users/attachments/20091124/024fdaa0/attachment.png">https://lists.berlios.de/pipermail/chan-sccp-users/attachments/20091124/024fdaa0/attachment.png</A> 

------------------------------

_______________________________________________
Chan-sccp-users mailing list
<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">Chan-sccp-users at lists.berlios.de</A>
<A HREF="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">https://lists.berlios.de/mailman/listinfo/chan-sccp-users</A>


End of Chan-sccp-users Digest, Vol 32, Issue 2
**********************************************

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000487.html">[Chan-sccp-users] Unable to Make Calls Using SCCP
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#488">[ date ]</a>
              <a href="thread.html#488">[ thread ]</a>
              <a href="subject.html#488">[ subject ]</a>
              <a href="author.html#488">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/chan-sccp-users">More information about the Chan-sccp-users
mailing list</a><br>
</body></html>
